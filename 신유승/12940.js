/**
 * 두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 
 * 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 
 * 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.
 * 
 * 제한 사항
 * 두 수는 1이상 1000000이하의 자연수입니다.
 */

function solution(n, m) {
  const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
  const lcm = (a, b) => (a * b) / gcd(a, b);
  return [gcd(n, m), lcm(n, m)];
}

/**
 * 사실은 위 문제 풀려고, 약수 혹은 배수를 다 구해서 indexOf 함수를 사용해서 풀려고 생각해봤는데,
 * 도무지 비효율적이고 노가다라 구글링을 해봤습니다.
 * 
 * 유클리드 호제법
 * 두 자연수 A, B(A >= B)에 대하여
 * A / B = p ... r(p != 0)에서
 * A = B * p + r (0 <= r < B)이다.
 * A와 B의 최대공약수는 Bp+r과 B의 최대공약수와 같다.
 * 여기서 Bp는 B의 배수이고, r은 B의 배수가 아니므로 A와 B의 최대 공약수는 B와 r의 최대공약수와 같다.
 * G(A, B) = G(B, r)
 * 
 * 최소공배수는 두 수의 곱을 최대공약수로 나눈 값과 같다.
 */

// for문을 사용한 풀이
// function gcdlcm(a, b) {
//   var r;
//   for (var ab = a * b; r = a % b; a = b, b = r) { }
//   return [b, ab / b];
// }